<Meta title="Endpoints/Getting Started" />

## The `endpoints` Feature

The `endpoints` feature allows developers to define groups of endpoint definitions by resources. This generates corresponding code under `{outdir}/endpoints/{resource}/{endpoint}`, with each endpoint containing a pre-configured `useMutation` React hook.

This hook is fully aware of its endpoint context, including type definitions and the correct path for execution. By providing this context, `firestore-ts-client-builder` alleviates much of the setup and configuration traditionally required for data fetching.

---

## Detailed Endpoint Configuration

Each endpoint within `endpoints` contains several key properties:

- `method`: This is the HTTP method (e.g., 'GET', 'POST', 'PATCH', 'DELETE') to be used for the endpoint.

- `path`: This is the server path that the endpoint addresses. 

- `hook`: This specifies the type of hook generated for this endpoint. Currently, only `mutation` is supported.

- `requestBody`: This object describes the expected request body. It uses JSON Schema LIKE to define these properties.

- `successResponse`: This object describes the data expected in the server response. Like `requestBody`, it uses JSON Schema LIKE to define these properties.

Here is an example configuration:

```js
endpoints: {
    posts: {
        create: {
            method: 'POST',
            path: '/posts',
            hook: 'mutation',
            requestBody: {
                properties: {
                    title: { type: 'string', isRequired: true },
                    body: { type: 'string', isRequired: true },
                    userId: { type: 'string', isRequired: true },
                },
            },
            successResponse: {
                properties: {
                    id: { type: 'string', isRequired: true },
                    title: { type: 'string', isRequired: true },
                    body: { type: 'string', isRequired: true },
                    userId: { type: 'string', isRequired: true },
                },
            },
        },
    },
}
```

---

## Working with Path Parameters

Path parameters can be specified within `{}` in the path string. For example, the path `/posts/{postId}` includes a parameter `postId`. 

The generated hook automatically recognizes this as a parameter and will allow you to pass corresponding values when calling the hook. For instance, when calling `updatePostMutation`, you can pass the `postId` like so:

```jsx
updatePostMutation.mutate({
    params: {
        postId: 'your-post-id',
    },
    body: {
        title: 'Updated title',
        body: 'Updated body',
    },
}, {
    onSuccess: (updatedData) => {
        console.log('Updated data:', updatedData);
    },
});
```

---

## Using Generated Hooks

The hooks generated from the `endpoints` feature provide an easy interface for making requests. Here's how to use them in your components:

```jsx
import { FormEvent, useState } from 'react';
import { QueryClient, QueryClientProvider } from 'react-query';
import { Button, Input } from 'react-rainbow-components';
import useCreatePost from '~/data/endpoints/posts/create/useMutation';
import useUpdatePost from '~/data/endpoints/posts/update/useMutation';

const Form = () => {
    const [title, setTitle] = useState('');
    const createPostMutation = useCreatePost();
    const updatePostMutation = useUpdatePost();

    // Rest of your form component code...
};

const queryClient = new QueryClient();

const UseMutationExample = () => (
    <QueryClientProvider client={queryClient}>
        <Form />
    </QueryClientProvider>
);

export default UseMutationExample;
```

In this example, the hooks `useCreatePost` and `useUpdatePost` were generated by the `endpoints` feature and know exactly how to handle their respective operations.
