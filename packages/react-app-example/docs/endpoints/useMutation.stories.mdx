import { Meta } from '@storybook/addon-docs';
import { Playground } from 'storybook-addon-code-editor';
import { commonExports } from '../utils';
import StoryCode from './useMutation.source.tsx?raw'
import useCreateMutation from '../../src/data/endpoints/posts/create/useMutation';
import useUpdateMutation from '../../src/data/endpoints/posts/update/useMutation';

<Meta title="Endpoints/useMutation/Docs" />

## The `endpoints` Feature

The `endpoints` feature allows developers to define groups of endpoint definitions by resources. This generates corresponding code under `{outdir}/endpoints/{resource}/{endpoint}`, with each endpoint containing a pre-configured `useMutation` React hook.

This hook is fully aware of its endpoint context, including type definitions and the correct path for execution. By providing this context, `firestore-ts-client-builder` alleviates much of the setup and configuration traditionally required for data fetching.

---

## Detailed Endpoint Configuration

Each endpoint within `endpoints` contains several key properties:

- `method`: This is the HTTP method (e.g., 'GET', 'POST', 'PATCH', 'DELETE') to be used for the endpoint.

- `path`: This is the server path that the endpoint addresses. 

- `hook`: This specifies the type of hook generated for this endpoint. Currently, only `mutation` is supported.

- `requestBody`: This object describes the expected request body. It uses JSON Schema LIKE to define these properties.

- `successResponse`: This object describes the data expected in the server response. Like `requestBody`, it uses JSON Schema LIKE to define these properties.

Here is an example configuration:

```js
endpoints: {
    posts: {
        create: {
            method: 'POST',
            path: '/posts',
            hook: 'mutation',
            requestBody: {
                properties: {
                    title: { type: 'string', isRequired: true },
                    body: { type: 'string', isRequired: true },
                    userId: { type: 'string', isRequired: true },
                },
            },
            successResponse: {
                properties: {
                    id: { type: 'string', isRequired: true },
                    title: { type: 'string', isRequired: true },
                    body: { type: 'string', isRequired: true },
                    userId: { type: 'string', isRequired: true },
                },
            },
        },
    },
}
```

---

## Working with Path Parameters

Path parameters can be specified within `{}` in the path string. For example, the path `/posts/{postId}` includes a parameter `postId`. 

The generated hook automatically recognizes this as a parameter and will allow you to pass corresponding values when calling the hook. For instance, when calling `updatePostMutation`, you can pass the `postId` like so:

```jsx
updatePostMutation.mutate({
    params: {
        postId: 'your-post-id',
    },
    body: {
        title: 'Updated title',
        body: 'Updated body',
    },
}, {
    onSuccess: (updatedData) => {
        console.log('Updated data:', updatedData);
    },
});
```

---

## Using Generated Hooks

The hooks generated from the `endpoints` feature provide an easy interface for making requests. Here's how to use them in your components:

```jsx
import { FormEvent, useState } from 'react';
import { QueryClient, QueryClientProvider } from 'react-query';
import { Button, Input } from 'react-rainbow-components';
import useCreatePost from '~/data/endpoints/posts/create/useMutation';
import useUpdatePost from '~/data/endpoints/posts/update/useMutation';

const Form = () => {
    const [title, setTitle] = useState('');
    const createPostMutation = useCreatePost();
    const updatePostMutation = useUpdatePost();

    // Rest of your form component code...
};

const queryClient = new QueryClient();

const UseMutationExample = () => (
    <QueryClientProvider client={queryClient}>
        <Form />
    </QueryClientProvider>
);

export default UseMutationExample;
```

In this example, the hooks `useCreatePost` and `useUpdatePost` were generated by the `endpoints` feature and know exactly how to handle their respective operations.

### Example

Here's an example of how to use the `useMutation` hook to create a blog post and update it:

<Playground code={StoryCode} availableImports={{ 
    ...commonExports, 
    '~/data/endpoints/posts/create/useMutation': useCreateMutation,
    '~/data/endpoints/posts/update/useMutation': useUpdateMutation 
}} height="520px" />

## Troubleshooting

If you encounter issues with the `endpoints` feature, start by checking the endpoint definitions in your project configuration and the structure of your endpoint usage. Remember, each endpoint should be grouped by its resource, and each resource can support multiple endpoints. If problems persist, check the `firestore-ts-client-builder` GitHub page for known issues or to file a new one.

Thank you for using `firestore-ts-client-builder`! We hope this guide helps
